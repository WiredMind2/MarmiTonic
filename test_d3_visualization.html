<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Disjoint Force-Directed Graph Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            background-color: #f0f0f0;
        }
        .controls {
            margin: 20px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        button {
            padding: 8px 16px;
            background-color: #4e79a7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #3a5f8a;
        }
    </style>
</head>
<body>
    <h1>D3.js Disjoint Force-Directed Graph Test</h1>
    
    <div class="controls">
        <button id="highlight-components">Highlight Disjoint Components</button>
        <div>
            <label>Force Strength: <input type="range" id="force-strength" min="0.01" max="0.5" step="0.01" value="0.1"></label>
            <label>Distance: <input type="range" id="distance" min="50" max="200" step="10" value="100"></label>
            <label>Charge: <input type="range" id="charge" min="-100" max="-10" step="5" value="-50"></label>
        </div>
    </div>
    
    <div id="graph-container" class="graph-container"></div>

    <script>
// D3.js Disjoint Force-Directed Graph Implementation
class D3DisjointForceGraph {
    constructor(containerSelector, width = 800, height = 600) {
        this.container = d3.select(containerSelector);
        this.width = width;
        this.height = height;
        this.simulation = null;
        this.nodes = [];
        this.links = [];
        this.svg = null;
        this.nodeElements = null;
        this.linkElements = null;
        this.forceStrength = 0.1;
        this.distance = 100;
        this.chargeStrength = -50;
        
        this.init();
    }

    init() {
        // Clear container
        this.container.html('');

        // Create SVG
        this.svg = this.container.append('svg')
            .attr('width', this.width)
            .attr('height', this.height)
            .attr('viewBox', [-this.width / 2, -this.height / 2, this.width, this.height])
            .style('background-color', '#f0f0f0');

        // Add zoom and pan functionality
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on('zoom', (event) => {
                this.svg.selectAll('g').attr('transform', event.transform);
            });

        this.svg.call(zoom);

        // Create a group for all graph elements
        this.graphGroup = this.svg.append('g');
    }

    updateData(graphData) {
        if (!graphData || !graphData.nodes || !graphData.links) {
            console.error('Invalid graph data format');
            return;
        }

        this.nodes = graphData.nodes;
        this.links = graphData.links;

        // Stop any existing simulation
        if (this.simulation) {
            this.simulation.stop();
        }

        this.renderGraph();
    }

    renderGraph() {
        // Clear previous elements
        this.graphGroup.selectAll('*').remove();

        // Create simulation with disjoint force layout
        this.simulation = d3.forceSimulation(this.nodes)
            .force('link', d3.forceLink(this.links).id(d => d.id).distance(this.distance))
            .force('charge', d3.forceManyBody().strength(this.chargeStrength))
            .force('center', d3.forceCenter(0, 0))
            .force('collide', d3.forceCollide().radius(20))
            .on('tick', () => this.ticked());

        // Create links
        this.linkElements = this.graphGroup.append('g')
            .selectAll('line')
            .data(this.links)
            .enter().append('line')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => Math.sqrt(d.value || 1));

        // Create nodes with different colors for different types
        this.nodeElements = this.graphGroup.append('g')
            .selectAll('circle')
            .data(this.nodes)
            .enter().append('circle')
            .attr('r', 10)
            .attr('fill', d => this.getNodeColor(d.type))
            .attr('stroke', '#fff')
            .attr('stroke-width', 1.5)
            .call(this.drag(this.simulation));

        // Add tooltips
        this.nodeElements.append('title')
            .text(d => `${d.name} (${d.type})`);

        // Add labels
        this.graphGroup.append('g')
            .selectAll('text')
            .data(this.nodes)
            .enter().append('text')
            .text(d => d.name)
            .attr('font-size', '10px')
            .attr('dx', 15)
            .attr('dy', '.35em')
            .attr('fill', '#333');

        // Add legend
        this.addLegend();
    }

    ticked() {
        this.linkElements
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        this.nodeElements
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);

        this.graphGroup.selectAll('text')
            .attr('x', d => d.x)
            .attr('y', d => d.y);
    }

    drag(simulation) {
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }

    getNodeColor(type) {
        const colors = {
            'cocktail': '#4e79a7',
            'ingredient': '#f28e2b',
            'unknown': '#e15759',
            'default': '#76b7b2'
        };
        return colors[type] || colors.default;
    }

    addLegend() {
        const legendData = [
            {type: 'cocktail', color: '#4e79a7'},
            {type: 'ingredient', color: '#f28e2b'}
        ];

        const legend = this.graphGroup.append('g')
            .attr('class', 'legend')
            .attr('transform', `translate(${this.width/2 - 100}, ${this.height/2 - 50})`);

        legend.selectAll('rect')
            .data(legendData)
            .enter().append('rect')
            .attr('x', 0)
            .attr('y', (d, i) => i * 20)
            .attr('width', 15)
            .attr('height', 15)
            .attr('fill', d => d.color);

        legend.selectAll('text')
            .data(legendData)
            .enter().append('text')
            .attr('x', 20)
            .attr('y', (d, i) => i * 20 + 12)
            .text(d => d.type)
            .attr('font-size', '12px')
            .attr('fill', '#333');
    }

    // Disjoint graph specific methods
    highlightDisjointComponents() {
        // Find connected components
        const components = this.findConnectedComponents();
        
        // Color nodes by component
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
        
        this.nodeElements
            .attr('fill', d => colorScale(components.find(c => c.includes(d.id))?.index || 0));
    }

    findConnectedComponents() {
        // Create adjacency list
        const adj = {};
        this.nodes.forEach(node => {
            adj[node.id] = [];
        });
        
        this.links.forEach(link => {
            adj[link.source.id].push(link.target.id);
            adj[link.target.id].push(link.source.id);
        });

        // Find connected components using BFS
        const visited = new Set();
        const components = [];
        let componentIndex = 0;

        this.nodes.forEach(node => {
            if (!visited.has(node.id)) {
                const component = [];
                const queue = [node.id];
                visited.add(node.id);

                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);

                    adj[current].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    });
                }

                components.push({
                    nodes: component,
                    index: componentIndex++
                });
            }
        });

        return components;
    }

    setForceParameters(forceStrength, distance, chargeStrength) {
        this.forceStrength = forceStrength;
        this.distance = distance;
        this.chargeStrength = chargeStrength;
        
        if (this.simulation) {
            this.simulation
                .force('link', d3.forceLink(this.links).id(d => d.id).distance(this.distance))
                .force('charge', d3.forceManyBody().strength(this.chargeStrength))
                .alpha(1).restart();
        }
    }

    destroy() {
        if (this.simulation) {
            this.simulation.stop();
        }
        this.container.html('');
    }
}

// Test data
const testData = {
    nodes: [
        {id: 'Margarita', name: 'Margarita', type: 'cocktail'},
        {id: 'Tequila', name: 'Tequila', type: 'ingredient'},
        {id: 'Lime Juice', name: 'Lime Juice', type: 'ingredient'},
        {id: 'Triple Sec', name: 'Triple Sec', type: 'ingredient'},
        {id: 'Martini', name: 'Martini', type: 'cocktail'},
        {id: 'Gin', name: 'Gin', type: 'ingredient'},
        {id: 'Vermouth', name: 'Vermouth', type: 'ingredient'},
        {id: 'Olive', name: 'Olive', type: 'ingredient'}
    ],
    links: [
        {source: 'Margarita', target: 'Tequila', value: 1},
        {source: 'Margarita', target: 'Lime Juice', value: 1},
        {source: 'Margarita', target: 'Triple Sec', value: 1},
        {source: 'Martini', target: 'Gin', value: 1},
        {source: 'Martini', target: 'Vermouth', value: 1},
        {source: 'Martini', target: 'Olive', value: 1}
    ]
};

// Initialize and test the graph
const graph = new D3DisjointForceGraph('#graph-container', 1000, 600);
graph.updateData(testData);

// Setup controls
document.getElementById('highlight-components').addEventListener('click', () => {
    graph.highlightDisjointComponents();
});

document.getElementById('force-strength').addEventListener('input', (e) => {
    const forceStrength = parseFloat(e.target.value);
    const distance = parseInt(document.getElementById('distance').value);
    const charge = parseInt(document.getElementById('charge').value);
    
    graph.setForceParameters(forceStrength, distance, charge);
});

document.getElementById('distance').addEventListener('input', (e) => {
    const forceStrength = parseFloat(document.getElementById('force-strength').value);
    const distance = parseInt(e.target.value);
    const charge = parseInt(document.getElementById('charge').value);
    
    graph.setForceParameters(forceStrength, distance, charge);
});

document.getElementById('charge').addEventListener('input', (e) => {
    const forceStrength = parseFloat(document.getElementById('force-strength').value);
    const distance = parseInt(document.getElementById('distance').value);
    const charge = parseInt(e.target.value);
    
    graph.setForceParameters(forceStrength, distance, charge);
});

console.log('D3.js Disjoint Force-Directed Graph test initialized successfully!');
    </script>
</body>
</html>